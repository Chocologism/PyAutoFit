import logging
from abc import ABC, abstractmethod
from hashlib import md5
from typing import Union, Generator

from sqlalchemy.exc import OperationalError

from .session_wrapper import SessionWrapper

logger = logging.getLogger(
    __name__
)


class Identifiable(ABC):
    @property
    @abstractmethod
    def id(self) -> str:
        """
        A unique identifier generated by hashing a string
        """

    def __eq__(
            self,
            other: Union["Identifiable", str]
    ) -> bool:
        """
        Compares ids
        """
        if isinstance(
                other,
                Identifiable
        ):
            return self.id == other.id
        if isinstance(
                other,
                str
        ):
            return self.id == other
        return False


class Step(Identifiable):
    def __init__(self, *strings: str):
        """
        A collection of SQL statements executed as one step
        in a database migration.

        Parameters
        ----------
        strings
            SQL statements
        """
        self.strings = strings

    @property
    def id(self) -> str:
        """
        Hash generated from underlying SQL statements
        """
        return md5(
            ":".join(
                self.strings
            ).encode(
                "utf-8"
            )
        ).hexdigest()


class Revision(Identifiable):
    def __init__(self, steps):
        self.steps = steps

    @property
    def id(self):
        return md5(
            ":".join(
                step.id for step
                in self.steps
            ).encode("utf-8")
        ).hexdigest()

    def __sub__(self, other):
        return Revision(tuple(
            step for step in self.steps
            if step not in other.steps
        ))


class Migrator:
    def __init__(
            self,
            *steps: Step
    ):
        """
        Manages migration of an old database.

        The revision table is checked to see what version a database is on.
        This is compared to the identifier of the current revision to determine
        the set of Steps that must be executed to migrate the database.

        Parameters
        ----------
        steps
            All steps recorded for every migration
        """
        self._steps = steps

    @property
    def revisions(self) -> Generator[Revision, None, None]:
        for i in range(1, len(self._steps) + 1):
            yield Revision(
                self._steps[:i]
            )

    def get_steps(self, revision_id=None):
        for revision in self.revisions:
            if revision_id == revision.id:
                return (self.latest_revision - revision).steps

        return self._steps

    @property
    def latest_revision(self):
        return Revision(
            self._steps
        )

    def migrate(self, session):
        wrapper = SessionWrapper(
            session
        )
        steps = self.get_steps(
            wrapper.revision_id
        )
        for step in steps:
            for string in step.strings:
                try:
                    session.execute(
                        string
                    )
                except OperationalError as e:
                    pass

        wrapper.revision_id = self.latest_revision.id
